<html>
<body>


<script>
		var datestring = "2008-07-00";


		// By default assume datestring is a year only
		var options = {};
		options.timeZone = 'UTC';
		options.year = 'numeric';

		// Test for valid month, then day (because we use -00 to indicate no data)
		var m = null;
	
		if (!m) {	
			m = datestring.match(/^([0-9]{4})$/);
			if (m) {
				// year only
				datestring = m[1]; 
			}
		}
	
		if (!m) {		
			m = datestring.match(/^([0-9]{4})-([0-9]{2})-00/);
			if (m) {
			
				if (m[2] == '00') {
					// Javascript can't handle -00-00 date string so set to January 1st 
					// which won't be output as we're only outputting the year
					datestring = m[1] + '-01-01';
				} else {
					// We have a month but no day
					datestring = m[1] + '-' + m[2] + '-01';
					options.month = 'short';
				}		
			}
		}
	
		if (!m) {	
			m = datestring.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})/);
			if (m) {
				// we have yea, month, and day
				options.month = 'short';
				options.day = 'numeric';
			}
		}
	
		var d = new Date(datestring);
		datestring = d.toLocaleString('en-gb', options);
		
		alert(datestring);
	
	/*
	
		}
	else
	{
		var options = {};
		options.year = 'numeric';
		
		var utc_date = new Date(0);
		
		var values = [];
		
		// Test for valid month, then day (because we use -00 to indicate no data)
		var m = null;
	
		if (!m) {	
			m = datestring.match(/^([0-9]{4})$/);
			if (m) {
				// year only				
				var year = parseInt(m[1]);				
				values.push(year); 
				
				utc_date.setUTCFullYear(year);
			}
		}
	
		if (!m) {		
			m = datestring.match(/^([0-9]{4})-([0-9]{2})-00/);
			if (m) {
			
				if (m[2] == '00') {
					// year only
					var year = parseInt(m[1]);				
					values.push(year); 
					
					utc_date.setUTCFullYear(year);
				} else {
					// We have a month but no day
					var year = parseInt(m[1]);				
					values.push(year); 
					
					utc_date.setUTCFullYear(year);
					
					var month = m[2].replace(/^0/, '');
					month = parseInt(month) - 1;					
					utc_date.setUTCMonth(month);

					options.month = 'short';
				}		
			}
		}
	
		if (!m) {	
			m = datestring.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})/);
			if (m) {
				var year = parseInt(m[1]);				
				values.push(year); 
				
				utc_date.setUTCFullYear(year);
			
				var month = m[2].replace(/^0/, '');
				month = parseInt(month) - 1;					
				utc_date.setUTCMonth(month);
			
				var day = m[3].replace(/^0/, '');
				day = parseInt(day);
				values.push(day);
				utc_date.setUTCDate(day);
				 
				options.month = 'short';
				options.day = 'numeric';
			}
		}
	
		//alert(JSON.stringify(values));
    	datestring = utc_date.toLocaleString('en-gb', options);
	
	}
	
	
	
	
	*/
	
	
	
	
</script>



</body>
</html>